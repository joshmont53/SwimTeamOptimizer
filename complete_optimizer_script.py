#!/usr/bin/env python3
"""
Complete Swimming Team Optimization Script
==========================================

This script handles the optimization of swimmer assignments to events and relay teams.
It processes swimmer data, respects availability constraints, and handles pre-assignments.

Key Features:
- Filters out unavailable swimmers completely
- Respects pre-assignments (protected from optimization)
- Limits swimmers to maximum 2 events each
- Optimizes based on performance indices vs qualifying times
- Generates relay teams for all age categories

Data Flow:
1. Load swimmer data with availability filtering
2. Load county qualifying times
3. Process pre-assignments and protect them
4. Run optimization algorithm
5. Generate relay teams
6. Output results as JSON
"""

import sys
import json
import csv
from dataclasses import dataclass
import itertools

def convert_to_seconds_with_milliseconds(time_str):
    """Convert time string (MM:SS.MS or HH:MM:SS.MS) to decimal seconds"""
    if not time_str or time_str.strip() == '':
        return 0

    parts = time_str.strip().split(':')

    if len(parts) == 3:  # HH:MM:SS.MS
        hours = int(parts[0])
        minutes = int(parts[1])
        seconds_part = parts[2]
    elif len(parts) == 2:  # MM:SS.MS
        hours = 0
        minutes = int(parts[0])
        seconds_part = parts[1]
    else:
        return 0

    # Handle seconds and milliseconds
    if '.' in seconds_part:
        seconds, hundredths = seconds_part.split('.')
        seconds = int(seconds)
        hundredths = int(hundredths.ljust(2, '0'))  # Ensure 2-digit hundredths
    else:
        seconds = int(seconds_part)
        hundredths = 0

    total = hours * 3600 + minutes * 60 + seconds + hundredths / 100
    return round(total, 2)

@dataclass
class RelaySwimmer:
    """Data class for relay team members"""
    name: str
    age: int
    gender: str
    freestyle: float = None
    backstroke: float = None
    breaststroke: float = None
    butterfly: float = None

    def __hash__(self):
        return hash(self.name)

def main():
    # Input file names (generated by backend)
    member_pbs_file = 'member_pbs.csv'
    county_times_file = 'county_times_cleaned.csv'
    pre_assignments_file = 'pre_assignments.json'

    # Load pre-assignments from JSON file
    pre_assignments = {"individual": [], "relay": []}
    try:
        with open(pre_assignments_file, 'r') as f:
            pre_assignments = json.load(f)
        print(f"LOADED PRE-ASSIGNMENTS: {len(pre_assignments['individual'])} individual, {len(pre_assignments['relay'])} relay", file=sys.stderr)
    except Exception as e:
        print(f"ERROR LOADING PRE-ASSIGNMENTS: {e}", file=sys.stderr)

    # === CRITICAL SECTION: AVAILABILITY FILTERING ===
    # Load swimmer data - ONLY AVAILABLE SWIMMERS ARE INCLUDED
    swimmer_list = []
    total_rows_processed = 0
    
    with open(member_pbs_file, newline='') as f:
        reader = csv.reader(f)
        header = next(reader)  # Skip header
        
        for row in reader:
            total_rows_processed += 1
            
            # Only process Short Course (SC) times with sufficient columns
            if len(row) >= 14 and row[8] == 'SC':
                # CSV structure: First_Name,Last_Name,ASA_No,Date_of_Birth,Meet,Date,Event,SC_Time,Course,Gender,AgeTime,County_QT,Count_CT,County_Qualify,time_in_seconds,isAvailable
                #                0           1          2       3             4     5    6      7        8       9       10      11        12       13             14             15
                
                # Determine availability status
                if len(row) >= 16:  # Has explicit availability column
                    availability_value = row[15]
                elif len(row) == 15:  # Old format without availability column
                    availability_value = "true"  # Default to available
                else:
                    availability_value = "true"  # Fallback default
                
                # Parse availability
                is_available = availability_value.strip().lower() == 'true' if availability_value else True
                
                # *** KEY FILTERING STEP ***
                if is_available:
                    # Include swimmer in optimization
                    # Structure: [first_name, last_name, event, gender, age, time_seconds, asa_no]
                    time_seconds = row[14]  # time_in_seconds column
                    swimmer_list.append([row[0], row[1], row[6], row[9], row[10], time_seconds, row[2]])
                    print(f"INCLUDED: {row[0]} {row[1]} (ASA: {row[2]})", file=sys.stderr)
                else:
                    # *** EXCLUDE UNAVAILABLE SWIMMERS ***
                    print(f"EXCLUDED: {row[0]} {row[1]} (unavailable)", file=sys.stderr)

    print(f"FILTERING COMPLETE: {len(swimmer_list)} available swimmers from {total_rows_processed} total records", file=sys.stderr)

    # Early exit if no swimmers available
    if len(swimmer_list) == 0:
        error_result = {
            "individual": [],
            "relay": [],
            "stats": {"qualifyingTimes": 0, "averageIndex": 0, "relayTeams": 0, "totalEvents": 0},
            "error": "No available swimmers found for optimization"
        }
        print(json.dumps(error_result))
        sys.exit(1)

    # Load county qualifying times
    county_times = []
    with open(county_times_file, newline='') as f:
        reader = csv.reader(f)
        next(reader)  # Skip header
        for row in reader:
            if len(row) >= 6 and row[3] == 'SC' and row[4] == 'QT':
                county_times.append([row[0], convert_to_seconds_with_milliseconds(row[1]), row[2], row[5]])

    # Define all possible events with age categories
    event_list = [
        # 11U Events (50m distances)
        ['50m Freestyle', 11, 'Male'],
        ['50m Backstroke', 11, 'Male'],
        ['50m Breaststroke', 11, 'Male'],
        ['50m Butterfly', 11, 'Male'],
        ['50m Freestyle', 11, 'Female'],
        ['50m Backstroke', 11, 'Female'],
        ['50m Breaststroke', 11, 'Female'],
        ['50m Butterfly', 11, 'Female'],
        
        # 13U Events (100m distances)
        ['100m Freestyle', 13, 'Male'],
        ['100m Backstroke', 13, 'Male'],
        ['100m Breaststroke', 13, 'Male'],
        ['100m Butterfly', 13, 'Male'],
        ['100m Freestyle', 13, 'Female'],
        ['100m Backstroke', 13, 'Female'],
        ['100m Breaststroke', 13, 'Female'],
        ['100m Butterfly', 13, 'Female'],
        
        # 15U Events (100m distances)
        ['100m Freestyle', 15, 'Male'],
        ['100m Backstroke', 15, 'Male'],
        ['100m Breaststroke', 15, 'Male'],
        ['100m Butterfly', 15, 'Male'],
        ['100m Freestyle', 15, 'Female'],
        ['100m Backstroke', 15, 'Female'],
        ['100m Breaststroke', 15, 'Female'],
        ['100m Butterfly', 15, 'Female'],
        
        # 16U Events (100m + 200m IM)
        ['100m Freestyle', 16, 'Male'],
        ['100m Backstroke', 16, 'Male'],
        ['100m Breaststroke', 16, 'Male'],
        ['100m Butterfly', 16, 'Male'],
        ['200m Individual Medley', 16, 'Male'],
        ['100m Freestyle', 16, 'Female'],
        ['100m Backstroke', 16, 'Female'],
        ['100m Breaststroke', 16, 'Female'],
        ['100m Butterfly', 16, 'Female'],
        ['200m Individual Medley', 16, 'Female']
    ]

    # Build performance comparison list
    full_list = []
    for event in event_list:
        for swimmer in swimmer_list:
            # Match criteria: gender, event, and age eligibility
            if (swimmer[3] == event[2] and  # Gender match
                swimmer[2] == event[0] and  # Event match
                min(int(swimmer[4]), 16) <= event[1]):  # Age eligibility
                
                # Structure: [event, age_cat, gender, first_name, last_name, time, asa_no]
                full_list.append([event[0], event[1], event[2], swimmer[0], swimmer[1], float(swimmer[5]), swimmer[6]])

    # Add qualifying times and calculate performance indices
    for i, entry in enumerate(full_list):
        for county_time in county_times:
            if (county_time[0] == entry[0] and  # Event match
                int(county_time[2]) == entry[1] and  # Age category match
                county_time[3] == entry[2]):  # Gender match
                
                # Add qualifying time
                entry.append(county_time[1])
                
                # Calculate performance metrics
                swimmer_time = float(entry[5])
                qualifying_time = county_time[1]
                time_diff = round(swimmer_time - qualifying_time, 2)
                performance_index = round(time_diff / qualifying_time, 3)
                
                entry.append(time_diff)
                entry.append(performance_index)
                break
        else:
            # No qualifying time found - mark as None
            entry.append(None)

    # Sort by performance index (best first)
    full_list.sort(key=lambda x: (x[-1] is None, x[-1]))

    # Initialize event tracking
    for event in event_list:
        event.append('Not allocated')  # Add allocation status

    # Add full names to entries
    for entry in full_list:
        full_name = f"{entry[3]} {entry[4]}"
        entry.append(full_name)

    # === PRE-ASSIGNMENT PROCESSING ===
    swimmer_event_count = {}
    protected_events = set()  # Events that can't be overwritten by optimization
    
    print(f"Processing {len(pre_assignments.get('individual', []))} individual pre-assignments", file=sys.stderr)
    
    for assignment in pre_assignments.get("individual", []):
        # Find swimmer by ASA number
        target_asa = str(assignment['swimmerId']).strip()
        swimmer_name = None
        
        for entry in full_list:
            if str(entry[6]).strip() == target_asa:
                swimmer_name = f"{entry[3]} {entry[4]}"
                break
        
        if swimmer_name:
            event_match = assignment['event']
            age_match = assignment['ageCategory']
            
            # Handle gender format conversion
            gender_mapping = {'M': 'Male', 'F': 'Female', 'Male': 'Male', 'Female': 'Female'}
            gender_match = gender_mapping.get(assignment['gender'])
            
            # Find and assign the event
            for event in event_list:
                if (event[0] == event_match and 
                    event[1] == age_match and 
                    event[2] == gender_match and
                    event[-1] == 'Not allocated'):
                    
                    event[-1] = swimmer_name
                    protected_events.add((event[0], event[1], event[2]))
                    swimmer_event_count[swimmer_name] = swimmer_event_count.get(swimmer_name, 0) + 1
                    print(f"PRE-ASSIGNED: {swimmer_name} → {event_match} {age_match} {gender_match}", file=sys.stderr)
                    break
        else:
            print(f"WARNING: Pre-assignment swimmer not found: ASA {assignment['swimmerId']}", file=sys.stderr)

    # === OPTIMIZATION ALGORITHM ===
    optimization_assignments = 0
    
    for entry in full_list:
        swimmer_name = entry[-1]  # Full name (added earlier)
        
        # Check current event count (including pre-assignments)
        current_count = swimmer_event_count.get(swimmer_name, 0)
        if current_count >= 2:  # Maximum 2 events per swimmer
            continue
        
        # Find available event for this swimmer
        for event in event_list:
            if (event[0] == entry[0] and  # Event match
                event[1] == entry[1] and  # Age category match
                event[2] == entry[2]):     # Gender match
                
                # Skip protected (pre-assigned) events
                event_key = (event[0], event[1], event[2])
                if event_key in protected_events:
                    continue
                
                # Assign if available
                if event[-1] == 'Not allocated':
                    event[-1] = swimmer_name
                    swimmer_event_count[swimmer_name] = current_count + 1
                    optimization_assignments += 1
                    print(f"OPTIMIZED: {swimmer_name} → {event[0]} {event[1]} {event[2]}", file=sys.stderr)
                    break

    print(f"OPTIMIZATION COMPLETE: {optimization_assignments} auto-assigned, {len(protected_events)} pre-assigned", file=sys.stderr)

    # === RELAY TEAM GENERATION ===
    # Build relay swimmers database
    relay_swimmers = {}
    for swimmer in swimmer_list:
        name = f"{swimmer[0]} {swimmer[1]}"
        stroke = swimmer[2]
        
        try:
            time = float(swimmer[5])
        except (TypeError, ValueError):
            continue
        
        age = min(int(swimmer[4]), 16)
        gender = swimmer[3]
        
        if name not in relay_swimmers:
            relay_swimmers[name] = RelaySwimmer(name=name, age=age, gender=gender)
        
        # Map strokes to relay swimmer attributes
        if stroke == "50m Freestyle":
            relay_swimmers[name].freestyle = time
        elif stroke == "50m Backstroke":
            relay_swimmers[name].backstroke = time
        elif stroke == "50m Breaststroke":
            relay_swimmers[name].breaststroke = time
        elif stroke == "50m Butterfly":
            relay_swimmers[name].butterfly = time

    # Generate relay teams for each age category and gender
    relay_assignments = []
    
    relay_events = [
        # 11U Relays (4x50m)
        ("4x50m Freestyle", 11, "Male"),
        ("4x50m Freestyle", 11, "Female"),
        ("4x50m Medley", 11, "Male"),
        ("4x50m Medley", 11, "Female"),
        
        # 13U Relays (4x50m)
        ("4x50m Freestyle", 13, "Male"),
        ("4x50m Freestyle", 13, "Female"),
        ("4x50m Medley", 13, "Male"),
        ("4x50m Medley", 13, "Female"),
        
        # 15U Relays (4x100m)
        ("4x100m Freestyle", 15, "Male"),
        ("4x100m Freestyle", 15, "Female"),
        ("4x100m Medley", 15, "Male"),
        ("4x100m Medley", 15, "Female"),
        
        # 16U Relays (4x100m)
        ("4x100m Freestyle", 16, "Male"),
        ("4x100m Freestyle", 16, "Female"),
        ("4x100m Medley", 16, "Male"),
        ("4x100m Medley", 16, "Female"),
    ]

    for relay_name, age_limit, gender in relay_events:
        # Filter eligible swimmers
        eligible = [s for s in relay_swimmers.values() 
                   if s.age <= age_limit and s.gender == gender]
        
        if len(eligible) < 4:
            continue
        
        if "Freestyle" in relay_name:
            # Freestyle relay - use best freestyle times
            swimmers_with_times = [(s, s.freestyle) for s in eligible if s.freestyle]
            swimmers_with_times.sort(key=lambda x: x[1])  # Sort by time
            
            if len(swimmers_with_times) >= 4:
                team = swimmers_with_times[:4]
                total_time = sum(swimmer[1] for swimmer in team)
                
                relay_assignments.append({
                    "relayName": relay_name,
                    "ageCategory": age_limit,
                    "gender": gender,
                    "swimmers": [{"name": s[0].name, "stroke": "Freestyle", "time": s[1]} for s in team],
                    "totalTime": round(total_time, 2)
                })
        
        elif "Medley" in relay_name:
            # Medley relay - need one swimmer for each stroke
            strokes = ["backstroke", "breaststroke", "butterfly", "freestyle"]
            team = []
            used_swimmers = set()
            
            for stroke in strokes:
                best_swimmer = None
                best_time = float('inf')
                
                for swimmer in eligible:
                    if swimmer.name in used_swimmers:
                        continue
                    
                    stroke_time = getattr(swimmer, stroke)
                    if stroke_time and stroke_time < best_time:
                        best_time = stroke_time
                        best_swimmer = swimmer
                
                if best_swimmer:
                    team.append((best_swimmer, stroke.capitalize(), best_time))
                    used_swimmers.add(best_swimmer.name)
            
            if len(team) == 4:
                total_time = sum(swimmer[2] for swimmer in team)
                relay_assignments.append({
                    "relayName": relay_name,
                    "ageCategory": age_limit,
                    "gender": gender,
                    "swimmers": [{"name": s[0].name, "stroke": s[1], "time": s[2]} for s in team],
                    "totalTime": round(total_time, 2)
                })

    # === RESULTS COMPILATION ===
    # Compile individual event results
    individual_results = []
    for event in event_list:
        if event[-1] != 'Not allocated':
            individual_results.append({
                "event": event[0],
                "ageCategory": event[1],
                "gender": event[2],
                "swimmer": event[-1],
                "isPreAssigned": (event[0], event[1], event[2]) in protected_events
            })

    # Calculate statistics
    qualifying_swimmers = len([e for e in full_list if len(e) > 7 and e[8] <= 0])  # Time diff <= 0
    total_events = len(event_list)
    assigned_events = len(individual_results)
    
    average_index = 0
    valid_indices = [e[9] for e in full_list if len(e) > 9 and e[9] is not None]
    if valid_indices:
        average_index = round(sum(valid_indices) / len(valid_indices), 3)

    # Final results
    results = {
        "individual": individual_results,
        "relay": relay_assignments,
        "stats": {
            "qualifyingTimes": qualifying_swimmers,
            "averageIndex": average_index,
            "relayTeams": len(relay_assignments),
            "totalEvents": total_events,
            "assignedEvents": assigned_events,
            "unassignedEvents": total_events - assigned_events
        }
    }

    # Output JSON results
    print(json.dumps(results))

if __name__ == "__main__":
    main()